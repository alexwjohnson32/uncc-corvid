# HELICS Query Capabilities Reference

This document provides a comprehensive guide to the query system in HELICS (Hierarchical Engine for Large-scale Infrastructure Co-Simulation), specifically tailored for C++ developers using Boost 1.78 for data parsing.

This was orignally generated by Google Gemini, so update if you find anything is incorrect.

## 1. Overview of the Query System

Queries are an asynchronous mechanism to retrieve metadata, topology, and status information from a running federation.

### The Query Workflow:

| Step | Description |
| :--- | :--- |
| Target | Define who you are asking (root, core, broker, or a specific name). |
| Query String | Define what you are asking (publications, version, etc.). |
| Execute | Use a federate object to send the request and receive a string (usually JSON). |
| Parse | Convert the response string into a usable object (e.g., using `boost::json`). |

## 2. Universal Queries

Available on almost any target (root, broker, core, or specific federate).

| Query String | Description | Response Example |
| :--- | :--- | :--- |
| version | Returns the HELICS library version. | `"3.5.1 (2024-03-20)"` |
| name | Returns the name of the target object. | `"GeneratorFed"` |
| isconnected | Checks if the target is active in the federation. | `"true"` |
| exists | Checks if the target object is known to exist. | `"true"` |
| tags | Returns user-defined tags as a JSON object. | `{"type": "solar", "id": "123"}` |
| queries | Self-discovery: Returns all valid query strings for this target. | `["version", "name", ...]` |

## 3. Federate-Specific Queries

Directed at a specific federate name or the local federate object.

| Query String | Description |
| :--- | :--- |
| state | Current execution state (`startup`, `initialization`, `execution`, `finalize`). |
| publications | JSON list of all publication keys belonging to the federate. |
| inputs | JSON list of all input/subscription keys. |
| endpoints | JSON list of all message endpoints. |
| publication_details | Detailed JSON object including types, units, and tags for publications. |
| input_details | Detailed JSON object including source links and types for inputs. |
| dependencies | List of federates/cores that this federate depends on for time. |
| current_time | The last granted time of the federate. |
| isinit | Returns `"true"` if the federate has entered initialization mode. |

## 4. Broker & Core Queries (Topology)

Directed at root, broker, core, or specific broker/core names. These provide the "macro" view.

| Query String | Description |
| :--- | :--- |
| federates | Returns a JSON array of all federate names in that scope. |
| federate_map | Hierarchical JSON map of brokers, cores, and federates. |
| data_flow_graph | A complete map of which publications are connected to which inputs. |
| dependency_graph | A map showing the timing dependencies between simulators. |
| global_time | Returns a JSON object with the current time of every federate. |
| global_state | Returns the current execution state of every component in the federation. |
| address | The network address (IP/Port) the core or broker is listening on. |

## 5. Advanced & Debugging Queries

| Query String | Description |
| :--- | :--- |
| global_time_debugging | Detailed internal timing state; used to find deadlocks. |
| logs | Retrieves recent log entries buffered in the target object. |
| version_all | JSON structure containing version info for every connected component. |
| barriers | Lists any active time barriers set in the federation. |

## 6. Understanding the '#error' State

When a query fails, HELICS returns the string literal `"#error"`. It is critical to check for this string before attempting to parse the result with Boost.JSON to avoid exceptions.

### Common Causes of `#error`:

| Error | Description |
| :--- | :--- |
| Invalid Target | The target name (e.g., a specific federate) does not exist or has already disconnected from the federation. |
| Invalid Query String | The target does not support the specific string requested (e.g., asking a Core for publications). |
| Timeout | The query message was lost or the target was too busy to respond within the internal HELICS timeout period. |
| Permission/Scope | You are querying a broker for information it doesn't have access to (e.g., a child broker's internal state from a peer). |

### Best Practice for C++ Handling:

```c++
std::string result = myQuery.execute(vFed);
if (result == "#error") {
    // Handle failure (log error, retry, or skip)
    std::cerr << "Query failed for target: " << myQuery.getTarget() << std::endl;
} else {
    // Safe to parse
    auto jv = json::parse(result);
}
```

## 7. Asynchronous vs. Blocking Calls

It is important to distinguish between how queries behave on the network versus how they behave in your C++ code.

### Network Level (Asynchronous)

Queries are inherently asynchronous at the federation level. They do not participate in the deterministic time-stepping logic of HELICS. A query can be sent, processed, and returned while other federates continue to advance their simulation clocks. It bypasses the "blocking" wait associated with time grants.

### API Level (Blocking by Default)

The standard `query.execute(vFed)` function is blocking. It sends the asynchronous network request and then pauses your thread until the response is received.

### Achieving Non-Blocking Queries

If your federate needs to perform calculations while waiting for a query response, use the Async pattern:

```c++
// Send the query and return immediately
vFed.queryExecuteAsync(myQuery);
// Perform other simulation work...
doCalculations();
// Retrieve the result (blocks only if the response hasn't arrived yet)
std::string result = vFed.queryExecuteComplete(myQuery);
```

## 8. C++ Implementation with Boost.JSON

Using Boost 1.78 to parse a list of federates and their publications.

```c++
#include <helics/cpp98/ValueFederate.hpp>
#include <boost/json.hpp>
#include <iostream>

namespace json = boost::json;

void discoverFederation(helics::ValueFederate& vFed) {
    try {
        // 1. Get all federates from the root
        helics::Query qFeds("root", "federates");
        std::string fedsRaw = qFeds.execute(vFed);

        if (fedsRaw == "#error") return;

        json::value fedsJv = json::parse(fedsRaw);
        if (!fedsJv.is_array()) return;

        for (const auto& fed : fedsJv.as_array()) {
            std::string name = json::value_to<std::string>(fed);
            std::cout << "Federate Found: " << name << std::endl;

            // 2. Query publications for each found federate
            helics::Query qPubs(name, "publications");
            std::string pubsRaw = qPubs.execute(vFed);

            if (pubsRaw != "#error") {
                json::value pubsJv = json::parse(pubsRaw);
                for (const auto& pub : pubsJv.as_array()) {
                    std::cout << "  -> Publication: " << pub << std::endl;
                }
            }
        }
    } catch (const std::exception& e) {
        std::cerr << "Parsing Error: " << e.what() << std::endl;
    }
}
```

## 9. Performance Considerations

### Blocking Nature

`query.execute()` is a blocking call. It will wait for the network round-trip.

### Path Traversal

A query to root from a leaf federate traverses: `Fed -> Core -> Broker -> Root -> Broker -> Core -> Fed`. This is slow in large federations.

### JSON Overhead

Parsing large `data_flow_graph` responses can be CPU-intensive. Cache these results rather than querying every time step.